

# 1 单线程


## 1.1 单线程

    Javascript就是单线程执行的

## 1.2 单线程缺点

    单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。
    如果前一个任务耗时很长，后一个任务就不得不一直等着。
    
## 1.3 回调
    
    很多时候IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。
    如果这时主线程完全不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。
    等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。
    


# 3 js运行机制

## 3.1 运行原理图

![](http://www.ruanyifeng.com/blogimg/asset/2014/bg2014100802.png)


## 区域划分

    stack
    
    callback queue
    
    eventloop

## 3.5 运行过程

    主线程开始
    1.main方法入栈,开始循序执行main内部代码
    2.遇到同步任务则立即执行
    3.遇到异步任务则立即执行
        异步任务执行完,则将相应的回调方法放入回调队列的尾部
    5.main方法执行完,则将回调队列中的方法入栈执行    
    


## 3.9 举例

    console.log('line 1')
    setTimeout(console.log, 1000, 'line 2')
    console.log('line 3')

    第一步，执行第一行，将结果line 1打印出来
    第二步，执行第二行，注意此时会将这个操作暂时存储到其他地方，因为setTimeout是一个异步执行操作。
    第三步，执行第三行，将结果line 3打印出出来
    第四步，等待最后一行程序（一共三行）都全部执行完了，
        然后立马实时查看刚才暂存的异步操作有没有。如果有可执行的，就立即拿到出来继续执行。
    第五步，执行完毕之后，再实时查看暂存位置中是否还有未执行的异步回调。





# 6 定时器

## 原理

    定时将事件插入了"任务队列"
    等待主线程有空

## 用法

    setTimeout()
        指定时间后执行一次回调函数
    setInterval()
        每隔指定时间后执行回调函数
        
## 特点

    延时     


## 案例

    console.log("1:"+new Date().getTime());
    setTimeout(function(){console.log("2:"+new Date().getTime());},1);
    setTimeout(function(){console.log("3:"+new Date().getTime());});
    console.log("4:"+new Date().getTime());

    1:1525439166254
    4:1525439166255
    undefined
    2:1525439166256
    3:1525439166256

