
# 单线程

单线程 

    Javascript语言的执行环境是"单线程"
    单线程只能顺序执行
    如果有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。

缺点

    单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。
    
    如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。
    
    JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。
    


# event-loop


原理

    将任务分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。
    同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；
    异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，
    只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。
流程

    具体来说，异步执行的运行机制如下。
    (1)所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
    (2)主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
    (3)一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
    (4)主线程不断重复上面的第三步。


举例

    console.log('line 1')
    setTimeout(console.log, 1000, 'line 2')
    console.log('line 3')

    第一步，执行第一行，将结果line 1打印出来
    第二步，执行第二行，注意此时会将这个操作暂时存储到其他地方，因为setTimeout是一个异步执行操作。
    第三步，执行第三行，将结果line 3打印出出来
    第四步，等待最后一行程序（一共三行）都全部执行完了，
        然后立马实时查看刚才暂存的异步操作有没有。如果有可执行的，就立即拿到出来继续执行。
    第五步，执行完毕之后，再实时查看暂存位置中是否还有未执行的异步回调。



异步回调  事件


# 异步实现

## 回调

    回调函数/promise

## 事件
    
    事件驱动




# 参考

http://www.ruanyifeng.com/blog/2014/10/event-loop.html

    
循序渐进(很好)

    http://www.cnblogs.com/wangfupeng1988/tag/%E5%BC%82%E6%AD%A5/